README contains the description of the files within the folder:

make_gwb_fault_json_bird_boundaries.ipynb : This is a jupyter notebook that generates World builder file defining plate
    boundaries/faults on the Earth's surface with the locations and geometries specified using an input JSON file. 
    The output world builder file contains geometry of plate boundaries as an assigned compositional field which 
    can be used in aspect for mantle convection models.
    The following json files are currently present in the directory defining different the plate boundary faults:

    1) gem_active_faults.geojson : This JSON file contains faults from the Global earthquake model database from
	   https://github.com/GEMScienceTools/gem-global-active-faults. 
	2) PB2002_steps.json         : This JSON file describes Peter Bird's 2003 plate boundary model as discrete 
       polygons/steps. The file was downloaded from https://github.com/fraxen/tectonicplates.
    3) Nuvel_plates.json         : To create the json, we use the text file containing the plate boundaries from 
	   http://jules.unavco.org/GMT/ and then use each segment separated by ">" as a fault segment in worldbuilder.
	   NOTE: We had to modify some segments where longitudes varied from 358 to 2 such that they varied from 178 to 
	   -178. This was done to ensure that the world builder connected the points along the shorter axis.

plate_boundaries.sh : This is the bash file used to plot plate boundaries using GMT4. The user can change the input
    files for plotting in the script. The input files are just the coordinates from the JSON files used above to create
	the world builder json file.

It also contains the workflow to take an ASPECT model output and:
	- convert P,T,d,f to Vs, Q
	- write a world.dat file with P,T,d,Vp,Vs,Q,eta specified at each point
	- construct a relevant 1D profile (radial average, sectoral average, or local around raypath)
	- compute travel times, t* and eigenfrequencies
	
Inputs/choices:
a) Geodynamic model result
b) Mineral physics parameterisation
c) frequency

Step-by-step guide

1. Get aspect output file, .csv format. Put in aspect_output folder.

2. Edit MAKE_ALL file, specifying
	- aspect_output file name
	- translation MODEL to be used ('JF10_eBurg' or 'M11')
	- frequency, in Hz, MAKE SURE YOU SPECIFY AS A FLOAT
	also make sure all the other inputs in the file are correct, like run#, Ndo, and crust and core and Qk files
	
3. Run ./MAKE_ALL   - this will take a while
	 first, opens matlab and downsamples the aspect output to a much smaller random mesh
	 then, computes a processed ("translated") aspect output file, with all the anelastic velocities calculated. This script also corrects the pressures, by adding the minimum negative pressure to all P values. This script also deletes any points with negative grainsizes.
	 	> this will be named trans_run#_MODEL_freq
	 finally, opens matlab, reads this translated file, and performs the 1D averaging, producing a MINEOS-ready card file, as well as a pdf of the 1D model. 
	 	> these will be named 1D_rundescrip_MODEL_freq.model
	 this is performed by the make_1Dav.m script, which can also be run manually in matlab, to change the options or to make the additional plots that include 2D slices of velocity and grainsize, and a comparison of the raw aspect output model (with anharmonic velocities) with the processed model (with anelastic effects included).
	 
3.5. The above steps should be performed for all the different frequencies that you want to compare. You'll end up with a bunch of .model files, and pdf files showing the V and Q of these 1D models

3.6 Manually, compute the values for 1hz

4. Copy the model files into a folder on povel, and run the following script:



5. You will end up with files in the following directory tree:

	MODEL/
		  freq/
		  	   phase/	
		which contains path_STA# and ttandtstar.txt

